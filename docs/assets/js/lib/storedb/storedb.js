class StoreDatabaseAPI{constructor(){}async loadDb(){this.stores=JSON.parse(window.localStorage.getItem("DatabaseURLs")),this.ratingServers=JSON.parse(window.localStorage.getItem("RatingServers")),this.currentStore={index:0,url:this.stores[0]},this.currentRatingServer={index:0,url:this.ratingServers[0]},this.db={categories:{all:{name:i18next.t("all-apps"),icon:"fas fa-store"}},apps:{objects:{},downloadCounts:{},ratings:{}},generatedAt:null};for(const t of this.stores){const e=await fetch(t);if(!e.ok)continue;this.currentStore.index=this.stores.indexOf(t),this.currentStore.url=t;const r=await e.json();if([2,3].includes(r.version)){this.db.generatedAt=r.generated_at,this.db.categories.all={name:i18next.t("all-apps"),icon:"fas fa-store"},Object.assign(this.db.categories,r.categories);for(const t of r.apps)this.db.apps.objects[t.name]=t;break}}for(const t of this.ratingServers){const e=await fetch(`${t}/download_counter`);if(!e.ok)continue;this.currentRatingServer.index=this.ratingServers.indexOf(t),this.currentRatingServer.url=t,this.db.apps.downloadCounts=await e.json();const r=await fetch(`${t}/ratings`);if(r.ok){this.db.apps.ratings=await r.json();break}}}getAppsByCategory(t){const e=this;return new Promise((r,s)=>{this.db.categories.hasOwnProperty(t)||s(new Error('Category "'+t+'" does not exist!')),"all"==t&&r(this.db.apps.objects);const a=new Worker("assets/js/lib/storedb/workers/category-worker.js");a.onmessage=t=>{a.terminate(),r(t.data)},a.onerror=t=>{a.terminate(),s(t)},a.postMessage({apps:e.db.apps.objects,category:t})})}sortApps(t,e){const r=this;return new Promise((s,a)=>{const o=new Worker("assets/js/lib/storedb/workers/sort-worker.js");switch(o.onmessage=function(t){o.terminate(),s(t.data)},o.onerror=function(t){o.terminate(),a(t)},e){case"alphabetical":case"categorical":o.postMessage({sort:e,apps:t});break;case"popularity":o.postMessage({sort:e,apps:t,downloadCounts:r.db.apps.downloadCounts});break;case"ratings":o.postMessage({sort:e,apps:t,ratings:r.db.apps.ratings});break;default:console.warn("[StoreDb] Unable to sort, returning unsorted apps."),s(t)}})}searchApps(t){const e=this;return new Promise((r,s)=>{const a=new Worker("assets/js/lib/storedb/workers/search-worker.js");a.onmessage=t=>{a.terminate(),r(t.data)},a.onerror=t=>{a.terminate(),s(t)},a.postMessage({query:t,apps:e.db.apps.objects})})}async dlCountApp(t){await fetch(`${this.currentRatingServer.url}/download_counter/count/${t}`)}async getAppRatings(t){const e=await fetch(`${this.currentRatingServer.url}/ratings/${t}`);if(!e.ok)throw new Error(`Unable to fetch ratings for app ${t}.`);return await e.json()}async loginToRatingsAccount(t,e){if(!(await fetch(`${this.currentRatingServer.url}/checkuser`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({username:t,logintoken:e})})).ok)throw new Error("Unable to login.")}async createRatingsAccount(t,e){if(!(await fetch(`${this.currentRatingServer.url}/createuser`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({username:t,logintoken:e})})).ok)throw new Error("Unable to create account.")}async addNewRating(t,e,r,s,a){if(!(await fetch(`${this.currentRatingServer.url}/ratings/${r}/add`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({username:t,logintoken:e,points:s,description:a})})).ok)throw new Error(`Unable to create new rating for app ${r}.`)}}